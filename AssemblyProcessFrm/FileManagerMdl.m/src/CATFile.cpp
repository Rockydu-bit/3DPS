// COPYRIGHT Dassault Systemes 2015
//===================================================================
//
// CATFile.cpp
// Header definition of CATFile
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Oct 2015  Creation: Code generated by the CAA wizard  WANGJIAPENG
//===================================================================
#include "CATFile.h"
 
CATImplementClass( CATFile,
                   Implementation, 
                   CATStringObject,
                   CATNull );
 
CATFile* CATFile::m_pFile = NULL;
//-----------------------------------------------------------------------------
// CATFile : constructor
//-----------------------------------------------------------------------------
CATFile::CATFile():
    CATStringObject()
{
}

//-----------------------------------------------------------------------------
// CATFile : destructor
//-----------------------------------------------------------------------------
CATFile::~CATFile()
{
}
 
CATFile* CATFile::GetInstance()
{
	if (m_pFile == NULL)
	{
		m_pFile = new CATFile();
	}
	return m_pFile;
}

//-----------------------------------------------------------------------------
// CATFile : copy constructor
//-----------------------------------------------------------------------------
CATFile::CATFile(CATFile& original):
   CATStringObject(original)
{
}
 
//-----------------------------------------------------------------------------
// CATFile : equal operator
//-----------------------------------------------------------------------------
CATFile& CATFile::operator=(CATFile& original)
{
   CATStringObject::operator=(original);
   return *this;
}

CString CATFile::OpenOneFileAndName()
{
	CString strPathName;
	CString filter = _T("Html Files (*.html)|*.html|");
	CString def_ext = _T(".html");
	CFileDialog my_dlg(FALSE, def_ext, NULL, OFN_EXPLORER|OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT, filter , NULL);
	my_dlg.m_ofn.lpstrTitle = _T("保存所选信息");
	if (my_dlg.DoModal() == IDOK)
	{
		strPathName = my_dlg.GetPathName();
	}
	else
	{
		return _T("");
	}
	
	return strPathName;
}

CString CATFile::OpenOneFile()
{
	CString strPath = _T("");
	static TCHAR* szFilter = _T("Video Files(*.AVI;*.mpeg;*.mpg;*.wmv;*.rmvb)|*.AVI;*.mpeg;*.mpg;*.wmv;*.rmvb|");
	CFileDialog dlgOpen(TRUE, _T("打开NC文件"), NULL,OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT ,szFilter);
	if (dlgOpen.DoModal()!=IDOK)
	{
		AfxMessageBox(_T("请选择一个视频文件！"));
		return strPath;
	}
	strPath =dlgOpen.GetPathName();

	return strPath;
}

CString CATFile::OpenOneFolder()
{
	CString str;
	CStringA stra;
	CString strPath;

	TCHAR szBuffer[MAX_PATH] = {0};
	BROWSEINFO bi;
	ZeroMemory(&bi, sizeof(BROWSEINFO));
	bi.pszDisplayName = szBuffer;
	bi.lpszTitle = _T("请选择文件夹"); 
	bi.ulFlags = BIF_NEWDIALOGSTYLE | BIF_EDITBOX;
	bi.lpfn = 0;
	LPITEMIDLIST idl = SHBrowseForFolder(&bi); 
	if (idl) 
	{     
		SHGetPathFromIDList(idl, szBuffer);
		strPath = szBuffer;
		LPMALLOC pMalloc;
		if (SHGetMalloc(&pMalloc) == NO_ERROR)
		{
			pMalloc->Free(idl);
			pMalloc->Release();
		}
	}
	if (strPath == _T(""))
	{
		AfxMessageBox(_T("选择文件夹失败！请重试！"));
		return _T("");
	}

	return strPath;
}

CATBoolean CATFile::OpenOneOrMoreFiles(CString strType,CArray<CString,CString>& PathArray)
{
	PathArray.RemoveAll();
	CFileDialog openDlg(TRUE,NULL,NULL,OFN_ALLOWMULTISELECT);
	openDlg.m_ofn.lpstrFilter = strType;
	const int nMaxFiles = 1000;
	const int nMaxPathBuffer = (nMaxFiles*(MAX_PATH + 1)) + 1;
	LPWSTR pc = (LPWSTR)malloc(nMaxPathBuffer*sizeof(WCHAR));
	if (pc)
	{
		openDlg.GetOFN().lpstrFile = pc;
		openDlg.GetOFN().lpstrFile[0] = NULL;
		openDlg.m_ofn.nMaxFile = nMaxPathBuffer;
		if (openDlg.DoModal() != IDOK)
		{
			if (PathArray.IsEmpty())
			{
				AfxMessageBox(_T("请选择一个或多个零部件！"));
				return FALSE;
			}

			return FALSE;
		}
		POSITION pos = openDlg.GetStartPosition();
		while(pos)
		{
			CString fileName = openDlg.GetNextPathName(pos);
			PathArray.Add(fileName);
		}
		free(pc);
	}

	return TRUE;
}

CString CATFile::GetFileName(CString strFilePath)
{
	CString strName = _T("");
	int start = strFilePath.ReverseFind(_T('\\'))+1;
	int end = strFilePath.GetLength();
	strName = strFilePath.Mid(start,end);

	return strName;
}

CString CATFile::GetPartName(CString strPartName)
{
	CString strName = _T("");
	int start = 0;
	int end = strPartName.GetLength() - 8;
	strName = strPartName.Mid(start,end);

	return strName;
}

int CATFile::GetFileCount(CString strPath,CStringArray &strPathArray,CStringArray &strArray)
{
	int num;
	CFileFind find;
	if (find.FindFile(strPath))
	{
		while (find.FindNextFile())
		{
			strArray.Add(find.GetFileName());
			strPathArray.Add((find.GetFilePath()));
		}
		strArray.Add(find.GetFileName());
		strPathArray.Add((find.GetFilePath()));
	}
	num = strArray.GetSize();

	return num;
}

CATBoolean CATFile::DeletePathFile(CString strPath)
{
	CFileFind Finder;
	if (Finder.FindFile(strPath))
	{
		DeleteFile(strPath);
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}
